#ifndef DINAMIC_CIRCULAR_BUFFER_H
#define DINAMIC_CIRCULAR_BUFFER_H

#include <deque>
#include <optional>
#include <mutex>
#include <utility>

template <typename T>
class DynamicCircularBuffer
{
private:
	std::deque<T> buffer;
	std::mutex mutex;

	void Swap(DynamicCircularBuffer& other) noexcept;
public:
	
	DynamicCircularBuffer();
	~DynamicCircularBuffer();
	DynamicCircularBuffer(const DynamicCircularBuffer &copied);
	DynamicCircularBuffer& operator=(const DynamicCircularBuffer other)
		noexcept;
	DynamicCircularBuffer(DynamicCircularBuffer &&moved) noexcept;

	friend void swap(DynamicCircularBuffer& right,
		DynamicCircularBuffer& left) noexcept { right.Swap(left); }

	template <typename... Args>
	void put(Args &&...arguments);

	std::optional<T> get();
	void clear();
	bool isEmpty() const;
	int size() const;
};

#include "DynamicCircularBuffer.inl"

#endif /* DINAMIC_CIRCULAR_BUFFER_H  */

// Плюсы: 
// 1) Для реализации буфера используется стандартный контейнер deque, который
//    в свою очередь реализован как список небольших массивов, что объединяет
//    преимущества динамического массива и списка, т.е. элементы добавляются и
//    получаются быстро;
// 2) Есть функции проверки пуст ли буфер, получения текущего размера, очистки
//    буфера;
// 3) Есть перегруженные конструкторы и оператор присваивания для копирования
//    и перемещения с использованием идиом Copy-swap и Move-swap для 
//    обеспечения строгой безопасности исключений;
// 4) Буфер не переполняется и автоматически расширяется при добавлении
//    элементов;
// 5) При получении элемента из буфера возвращается тип std::optional<T>, 
//    который позволяет проверить наличие возвращаемого элемента, если 
//    буфер пуст возвращается std::nullopt;
// 6) Файлы класса .h и .cpp не зависят друг от друга по подключаемым include;
// 7) Класс шаблонный, можно использовать для разных типов;
// 8) Класс потокобезопасный;
// 9) Требуется меньше кода для реализации при использовании deque;
// 10) Реализация функций-членов шаблонного класса вынесена в файл .inl для
//    лучшей читаемости;
// 12) Для помещения элементов в буфер их можно копировать, перемещать
//    или сразу передавать параметры конструктора инкапсулируемого типа для
//    избегания лишних операций копирования и перемещения при помощи
//    функции put, которая использует идиому perfect forwarding и variadic
//    templates.
// Минусы:
// 1) Если объект класса буфера будет константным, например передан по
//	  константной ссылке, то получить или поместить значение в буфер не
//    получится т.к. методы get и put не константные и изменяют состояние
//    объекта, можно было бы сделать их константными, а так же сделать
//    переменные-члены mutable, но это бы вводило программиста в заблуждение
//    в неизменяемости объекта класса при использовании таких константных
//    методов;
// 2) Из-за использования mutex в качестве поля класса нельзя использовать
//    конструкторы и операторы присваивания по-умолчанию для копирования и
//    перемещения;
// 3) При использовании мьютексов происходят дополнительные накладные
//    расходы, даже если класс не используется для многопоточной работы,
//    возможно было бы целесообразно использовать мьютексы вне функций
//    класса, например можно было бы блокировать мьютекс при переборе 
//    буфера один раз, а не каждый раз при вызове функции get;
// 4) Более сложный синтаксис т.к. класс шаблонный.