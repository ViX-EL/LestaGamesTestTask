#ifndef REWRITABLE_CIRCULAR_BUFFER_H
#define REWRITABLE_CIRCULAR_BUFFER_H

#include <array>
#include <mutex>
#include <optional>
#include <utility>

template <typename T, int maxSize>
class RewritableCircularBuffer
{
private:
	void advanceIdx(int& index);

	bool full;
	int writeIdx;
	int readIdx;
	std::array<T, maxSize> buffer;
	std::mutex mutex;

	void Swap(RewritableCircularBuffer& other) noexcept;
public:

	RewritableCircularBuffer();
	~RewritableCircularBuffer();
	RewritableCircularBuffer(const RewritableCircularBuffer &copied);
	RewritableCircularBuffer(RewritableCircularBuffer &&moved) noexcept;
	RewritableCircularBuffer& operator=(RewritableCircularBuffer other)
		noexcept;

	friend void swap(RewritableCircularBuffer &right,
		RewritableCircularBuffer &left) noexcept { right.Swap(left); };

	void put(const T& item);
	void put(T&& item);
	std::optional<T> get();
	void reset();
	bool isEmpty() const;
	bool isFull() const;
	int capacity() const;
	int size() const;
};

#include"RewritableCircularBuffer.inl"

#endif /* REWRITABLE_CIRCULAR_BUFFER_H */

// Плюсы: 
// 1) Класс шаблонный, можно использовать для разных типов;
// 3) Для хранения буфера используется контейнер std::array, содержащий 
//    статический массив, который  может размещаться на стэке, а так же не
//    нужно следить за очисткой памяти;
// 4) Если будет передано отрицательное значение размера в параметрах шаблона,
// 	  то std::array не позволит скомпилировать такой код, возможно стоит также
//    как-то (пока не уверен как) проверять некорректный размер в конструкторе;
// 5) Класс потокобезопасный;
// 6) Есть функции проверки заполнен ли буфер, пуст ли буфер,
// 	  получения вместимости буфера и текущего размера, сброса буфера;
// 7) Для продвижения индексов чтения и записи избегаются более затратные
//    операции деления по модулю, чем просто условная конструкция if;
// 8) Буфер перезаписывается при переполнении (новые элементы записываются
//    поверх старых);
// 9) При получении элемента из буфера возвращается тип std::optional<T>, 
//    который позволяет проверить наличие возвращаемого элемента, если 
//    буфер пуст возвращается std::nullopt;
// 10) Реализация функций-членов шаблонного класса вынесена в файл .inl для
//    лучшей читаемости;
// 11) Файлы класса .h и .cpp не зависят друг от друга по подключаемым include;
// 12) Для помещения элементов в буфер их можно копировать или перемещать
//    при помощи перегруженной функции put;
// 13) Есть перегруженные конструкторы и оператор присваивания для копирования
//    и перемещения с использованием идиом Copy-swap и Move-swap для 
//    обеспечения строгой безопасности исключений;
// Минусы:
// 1) При использовании мьютексов происходят дополнительные накладные
//    расходы, даже если класс не используется для многопоточной работы,
//    возможно было бы целесообразно использовать мьютексы вне функций
//    класса, например можно было бы блокировать мьютекс при переборе 
//    буфера один раз, а не каждый раз при вызове функции get;
// 2) Более сложный синтаксис т.к. класс шаблонный;
// 3) Дополнительные накладные расходы памяти при получении значения из буфера
//    (при использовании std::optional<T> выделяется дополнительная память
//    из-за выравнивания), можно вместо этого возвращать значение по-умолчанию
//    для типа;
// 4) Буфер статической, фиксированной длины;
// 5) Если объект класса буфера будет константным, например передан по
// 	  константной ссылке, то получить или поместить значение в буфер не
//    получится т.к. методы get и put не константные и изменяют состояние
//    объекта, можно было бы сделать их константными, а так же сделать
//    переменные-члены mutable, но это бы вводило программиста в заблуждение
//    в неизменяемости объекта класса при использовании таких константных
//    методов
// 6) Для передачи по ссылке и перемещения в методе put, без использования
//    идиомы perfect forwarding, метод put приходится перегружать и происходит
//    дублирование кода.


// Дополнительно можно объявить конструкторы и операторы присваивания для
// инициализации с помощью initializers_list.