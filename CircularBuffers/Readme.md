## Задание:
На языке С++, написать минимум по 2 класса реализовывающих циклический буфер.

Объяснить плюсы и минусы каждой реализации.

## Решение:
Было написано 3 реализации циклическоко буфера: CircularBuffer
(с использованием указателя для хранения буфера в виде динамического массива),
DynamicCircularBuffer (с использованием стандартного контейнера deque для
хранения и управления буфером, реализующего структуру данных дек -
двухстороннюю очередь) и RewritableCircularBuffer (с использованием
стандартного контейнера array для хранения буфера в виде массива статического
размера).

### CircularBuffer
#### Плюсы:
1) Есть функции проверки заполнен ли буфер, пуст ли буфер, получения
   вместимости буфера и текущего размера, сброса буфера, проверки буфера на
   null;
2) Есть функции изменения размера буфера с сохранением текущих элементов и 
	  без сохранения;
3) Есть перегруженные конструкторы и оператор присваивания для копирования
   и перемещения с использованием идиом Copy-swap и Move-swap;
4) Копирование глубокое, т.к. есть динамически выделяемая память;
5) При копировании копируется не весь буфер, а только элементы доступные для
   чтения;
6) Буфер не перезаписывается при переполнении (запись элементов не
   происходит, если буфер полон, выводится сообщение о том, что буфер
	  заполен, вместо вывода сообщения можно возвращать из функции логическое
   значение bool, информирующее об успешности записи в буфер);
7) При получении элемента из буфера, если буфер пуст, возвращается значение
   по умолчанию для типа int - 0 и выводится сообщение о том, что буфер
   пуст, возможно лучше использовать std::optional<T>, чтобы
   проверять наличие значения и возвращать пустое значение
   std::nullopt, когда буфер пуст, так же сообщения о пустоте/заполненности
   можно не выводить, если не требуется;
8) Файлы класса .h и .cpp не зависят друг от друга по подключаемым include.
#### Минусы:
1) Класс реализован только для типа int;
2) Конструктор может использоваться для неявных преобразований
   (не explicit);
3) Для передачи размера буфера в конструктор используется беззнаковый
   целочисленный тип, при передаче в конструктор отрицательного значения
	  будет применено неявное приведение к беззнаковому типу и получится
   его переполнение (может быть получено значение размера около,
   unsigned long long max, что приведёт к неожиданному поведению программы);
4) Для хранения буфера используется сырой указатель, нужно следить за
   очисткой памяти, заниматься этим вручную;
5) Класс не потокобезопасный;
6) Для продвижения индексов чтения применяются более затратные
   операции деления по модулю;
7) Функции capacity и size возвращают значение беззнакового целочисленного
   типа size_t, возможно лучше избегать беззнаковые типы и возвращать int,
   для избегания потенциальных ошибок с переполнением беззнакового типа;
8) Если объект класса буфера будет константным, например передан по
	  константной ссылке, то получить или поместить значение в буфер не
   получится т.к. методы get и put не константные и изменяют состояние
   объекта, можно было бы сделать их константными, а так же сделать
   переменные-члены mutable, но это бы вводило программиста в заблуждение
   в неизменяемости объекта класса при использовании таких константных
   методов;
9) Из-за использования указателя в качестве хранилища буфера вместо
   стандартных контейнеров приходится писать больше кода и перегружать
   конструкторы и операторы присваивания для копирования, перемещения
   и др.

### DynamicCircularBuffer
#### Плюсы: 
1) Для реализации буфера используется стандартный контейнер deque, который
   в свою очередь реализован как список небольших массивов, что объединяет
   преимущества динамического массива и списка, т.е. элементы добавляются и
   получаются быстро;
2) Есть функции проверки пуст ли буфер, получения текущего размера, очистки
   буфера;
3) Есть перегруженные конструкторы и оператор присваивания для копирования
   и перемещения с использованием идиом Copy-swap и Move-swap для 
   обеспечения строгой безопасности исключений;
4) Буфер не переполняется и автоматически расширяется при добавлении
   элементов;
5) При получении элемента из буфера возвращается тип std::optional<T>, 
   который позволяет проверить наличие возвращаемого элемента, если 
   буфер пуст возвращается std::nullopt;
6) Файлы класса .h и .cpp не зависят друг от друга по подключаемым include;
7) Класс шаблонный, можно использовать для разных типов;
8) Класс потокобезопасный;
9) Требуется меньше кода для реализации при использовании deque;
10) Реализация функций-членов шаблонного класса вынесена в файл .inl для
   лучшей читаемости;
12) Для помещения элементов в буфер их можно копировать, перемещать
   или сразу передавать параметры конструктора инкапсулируемого типа для
   избегания лишних операций копирования и перемещения при помощи
   функции put, которая использует идиому perfect forwarding и variadic
   templates.
#### Минусы:
1) Если объект класса буфера будет константным, например передан по
	  константной ссылке, то получить или поместить значение в буфер не
   получится т.к. методы get и put не константные и изменяют состояние
   объекта, можно было бы сделать их константными, а так же сделать
   переменные-члены mutable, но это бы вводило программиста в заблуждение
   в неизменяемости объекта класса при использовании таких константных
   методов;
2) Из-за использования mutex в качестве поля класса нельзя использовать
   конструкторы и операторы присваивания по-умолчанию для копирования и
   перемещения;
3) При использовании мьютексов происходят дополнительные накладные
   расходы, даже если класс не используется для многопоточной работы,
   возможно было бы целесообразно использовать мьютексы вне функций
   класса, например можно было бы блокировать мьютекс при переборе 
   буфера один раз, а не каждый раз при вызове функции get;
4) Более сложный синтаксис т.к. класс шаблонный.

### RewritableCircularBuffer
#### Плюсы: 
1) Класс шаблонный, можно использовать для разных типов;
3) Для хранения буфера используется контейнер std::array, содержащий 
   статический массив, который  может размещаться на стэке, а так же не
   нужно следить за очисткой памяти;
4) Если будет передано отрицательное значение размера в параметрах шаблона,
	  то std::array не позволит скомпилировать такой код, возможно стоит также
   как-то (пока не уверен как) проверять некорректный размер в конструкторе;
5) Класс потокобезопасный;
6) Есть функции проверки заполнен ли буфер, пуст ли буфер,
	  получения вместимости буфера и текущего размера, сброса буфера;
7) Для продвижения индексов чтения и записи избегаются более затратные
   операции деления по модулю, чем просто условная конструкция if;
8) Буфер перезаписывается при переполнении (новые элементы записываются
   поверх старых);
9) При получении элемента из буфера возвращается тип std::optional<T>, 
   который позволяет проверить наличие возвращаемого элемента, если 
   буфер пуст возвращается std::nullopt;
10) Реализация функций-членов шаблонного класса вынесена в файл .inl для
   лучшей читаемости;
11) Файлы класса .h и .cpp не зависят друг от друга по подключаемым include;
12) Для помещения элементов в буфер их можно копировать или перемещать
   при помощи перегруженной функции put;
13) Есть перегруженные конструкторы и оператор присваивания для копирования
   и перемещения с использованием идиом Copy-swap и Move-swap для 
   обеспечения строгой безопасности исключений;
#### Минусы:
1) При использовании мьютексов происходят дополнительные накладные
   расходы, даже если класс не используется для многопоточной работы,
   возможно было бы целесообразно использовать мьютексы вне функций
   класса, например можно было бы блокировать мьютекс при переборе 
   буфера один раз, а не каждый раз при вызове функции get;
2) Более сложный синтаксис т.к. класс шаблонный;
3) Дополнительные накладные расходы памяти при получении значения из буфера
   (при использовании std::optional<T> выделяется дополнительная память
   из-за выравнивания), можно вместо этого возвращать значение по-умолчанию
   для типа;
4) Буфер статической, фиксированной длины;
5) Если объект класса буфера будет константным, например передан по
	  константной ссылке, то получить или поместить значение в буфер не
   получится т.к. методы get и put не константные и изменяют состояние
   объекта, можно было бы сделать их константными, а так же сделать
   переменные-члены mutable, но это бы вводило программиста в заблуждение
   в неизменяемости объекта класса при использовании таких константных
   методов
6) Для передачи по ссылке и перемещения в методе put, без использования
   идиомы perfect forwarding, метод put приходится перегружать и происходит
   дублирование кода.