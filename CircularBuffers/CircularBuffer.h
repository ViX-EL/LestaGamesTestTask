#ifndef CIRCULAR_BUFFER_H
#define CIRCULAR_BUFFER_H

//#include <memory>

// Класс реализующий только буфер для типа int
class CircularBuffer
{
private:
	void advanceIdx(size_t &index) const;
	void erase();
	void copyAvailableForReading(const CircularBuffer &copied,
		size_t newCapacity);

	size_t maxSize;
	int* buffer; // Сырой указатель на буфер, память нужно очищать вручную.
	//std::unique_ptr<int[]> buffer; // лучше использовать умный указатель
	// а ещё лучше стандартные контейнеры, например: vector, array, deque, list
	size_t writeIdx;
	size_t readIdx;
	bool full;

public:
	// Конструктор, может использоваться для неявных преобразований
	// (конструктор преобразования), не explicit
	// А так же может быть передан например отрицательный int,
	// произойдёт неявное приведение к беззнаковому типу
	// и его переполнение, может получиться значение около
	// unsigned long long max, чего программист может не ожидать.
	CircularBuffer(size_t size);

	~CircularBuffer();
	CircularBuffer(const CircularBuffer &other);
	CircularBuffer & operator=(CircularBuffer other) noexcept;
	CircularBuffer(CircularBuffer &&moved) noexcept;

	friend void swap(CircularBuffer& right, CircularBuffer& left) noexcept;

	void reallocate(size_t newLength);
	void resize(size_t newLength);
	bool put(int item);
	int get();
	void reset();
	bool isEmpty() const;
	bool isFull() const;
	bool isNull() const;
	size_t capacity() const;
	size_t size() const;
};

#endif /* CIRCULAR_BUFFER_H */

// Плюсы: 
// 1) Есть функции проверки заполнен ли буфер, пуст ли буфер, получения
// 	  вместимости буфера и текущего размера, сброса буфера, проверки буфера на
//    null;
// 2) Есть функции изменения размера буфера с сохранением текущих элементов и 
//	  без сохранения;
// 3) Есть перегруженные конструкторы и оператор присваивания для копирования
//    и перемещения с использованием идиом Copy-swap и Move-swap;
// 4) Копирование глубокое, т.к. есть динамически выделяемая память;
// 5) При копировании копируется не весь буфер, а только элементы доступные для
//    чтения;
// 6) Буфер не перезаписывается при переполнении (запись элементов не
//    происходит, если буфер полон, выводится сообщение о том, что буфер
//	  заполен, вместо вывода сообщения можно возвращать из функции логическое
//    значение bool, информирующее об успешности записи в буфер);
// 7) При получении элемента из буфера, если буфер пуст, возвращается значение
//    по умолчанию для типа int - 0 и выводится сообщение о том, что буфер
//    пуст, возможно лучше использовать std::optional<T>, чтобы
//    проверять наличие значения и возвращать пустое значение
//    std::nullopt, когда буфер пуст, так же сообщения о пустоте/заполненности
//    можно не выводить, если не требуется;
// 8) Файлы класса .h и .cpp не зависят друг от друга по подключаемым include.
// Минусы:
// 1) Класс реализован только для типа int;
// 2) Конструктор может использоваться для неявных преобразований
//    (не explicit);
// 3) Для передачи размера буфера в конструктор используется беззнаковый
//    целочисленный тип, при передаче в конструктор отрицательного значения
//	  будет применено неявное приведение к беззнаковому типу и получится
//    его переполнение (может быть получено значение размера около,
//    unsigned long long max, что приведёт к неожиданному поведению программы);
// 4) Для хранения буфера используется сырой указатель, нужно следить за
//    очисткой памяти, заниматься этим вручную;
// 5) Класс не потокобезопасный;
// 6) Для продвижения индексов чтения применяются более затратные
//    операции деления по модулю;
// 7) Функции capacity и size возвращают значение беззнакового целочисленного
//    типа size_t, возможно лучше избегать беззнаковые типы и возвращать int,
//    для избегания потенциальных ошибок с переполнением беззнакового типа;
// 8) Если объект класса буфера будет константным, например передан по
//	  константной ссылке, то получить или поместить значение в буфер не
//    получится т.к. методы get и put не константные и изменяют состояние
//    объекта, можно было бы сделать их константными, а так же сделать
//    переменные-члены mutable, но это бы вводило программиста в заблуждение
//    в неизменяемости объекта класса при использовании таких константных
//    методов;
// 9) Из-за использования указателя в качестве хранилища буфера вместо
//    стандартных контейнеров приходится писать больше кода и перегружать
//    конструкторы и операторы присваивания для копирования, перемещения
//    и др.